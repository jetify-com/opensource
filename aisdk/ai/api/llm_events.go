package api

import (
	"encoding/json"
	"fmt"
	"time"
)

// TODO: Update events based on TextStreamPart:
// https://github.com/vercel/ai/blob/main/packages/ai/src/generate-text/stream-text-result.ts#L350
//
// Might also want to take a look at the SessionNotifications defined by the "agent client protocol":
// https://github.com/zed-industries/agent-client-protocol/blob/main/typescript/schema.ts#L893

// EventType represents the different types of stream events.
type EventType string

const (
	// EventTextDelta represents an incremental text response from the model.
	EventTextDelta EventType = "text-delta"

	// EventReasoning is an optional reasoning or intermediate explanation generated by the model.
	EventReasoning EventType = "reasoning"

	// EventReasoningSignature represents a signature that verifies reasoning content.
	EventReasoningSignature EventType = "reasoning-signature"

	// EventRedactedReasoning represents redacted reasoning data.
	EventRedactedReasoning EventType = "redacted-reasoning"

	// EventSource represents a citation that was used to generate the response.
	EventSource EventType = "source"

	// EventFile represents a file generated by the model.
	EventFile EventType = "file"

	// EventToolCall represents a completed tool call with all arguments provided.
	EventToolCall EventType = "tool-call"

	// EventToolCallDelta is an incremental update for tool call arguments.
	EventToolCallDelta EventType = "tool-call-delta"

	// EventResponseMetadata contains additional response metadata, such as timestamps or provider details.
	EventResponseMetadata EventType = "response-metadata"

	// EventFinish is the final part of the stream, providing the finish reason and usage statistics.
	EventFinish EventType = "finish"

	// EventError indicates that an error occurred during the stream.
	EventError EventType = "error"

	// TODO: How should we handle refusal events? Do we need an additional event type?
)

// StreamEvent represents a streamed incremental update of the language model output.
type StreamEvent interface {
	// Type returns the type of event being received.
	Type() EventType
}

// TextDeltaEvent represents an incremental text response from the model
//
// Used to update a TextBlock incrementally.
type TextDeltaEvent struct {
	// TextDelta is a partial text response from the model
	TextDelta string `json:"text_delta"`
}

func (b *TextDeltaEvent) Type() EventType { return EventTextDelta }

// ReasoningEvent represents an incremental reasoning response from the model.
//
// Used to update the text of a ReasoningBlock.
type ReasoningEvent struct {
	// TextDelta is a partial reasoning text from the model
	TextDelta string `json:"text_delta"`
}

func (b *ReasoningEvent) Type() EventType { return EventReasoning }

// ReasoningSignatureEvent represents an incremental signature update for reasoning text.
//
// Used to update the signature field of a ReasoningBlock.
type ReasoningSignatureEvent struct {
	// Signature is the cryptographic signature for verifying reasoning
	Signature string `json:"signature"`
}

func (b *ReasoningSignatureEvent) Type() EventType { return EventReasoningSignature }

// RedactedReasoningEvent represents an update to redacted reasoning data.
//
// Used to update the data field of a RedactedReasoningBlock.
type RedactedReasoningEvent struct {
	// Data contains redacted reasoning data
	Data string `json:"data"`
}

func (b *RedactedReasoningEvent) Type() EventType { return EventRedactedReasoning }

// SourceEvent represents a source that was used to generate the response.
//
// Used to add a source to the response.
type SourceEvent struct {
	// Source contains information about the source
	Source Source `json:"source"`
}

func (b *SourceEvent) Type() EventType { return EventSource }

// FileEvent represents a file generated by the model.
//
// Used to add a file to the response via a FileBlock.
type FileEvent struct {
	// MediaType is the IANA media type (mime type) of the file
	MediaType string `json:"media_type"`
	// Data contains the generated file as a byte array
	Data []byte `json:"data"`
}

func (b *FileEvent) Type() EventType { return EventFile }

// ToolCallEvent represents a complete tool call with all arguments.
//
// Used to add a tool call to the response via a ToolCallBlock.
type ToolCallEvent struct {
	// ToolCallID is the ID of the tool call. This ID is used to match the tool call with the tool result.
	ToolCallID string `json:"tool_call_id"`

	// ToolName is the name of the tool being invoked.
	ToolName string `json:"tool_name"`

	// Args contains the arguments of the tool call as a JSON payload matching
	// the tool's input schema.
	// Note that args are often generated by the language model and may be
	// malformed.
	Args json.RawMessage `json:"args"`
}

func (b *ToolCallEvent) Type() EventType { return EventToolCall }

////////////// Unify events above with content blocks?

// ToolCallDeltaEvent represents a tool call with incremental arguments.
// Tool call deltas are only needed for object generation modes.
// The tool call deltas must be partial JSON.
type ToolCallDeltaEvent struct {
	// ToolCallID is the ID of the tool call
	ToolCallID string `json:"tool_call_id"`

	// ToolName is the name of the tool being invoked
	ToolName string `json:"tool_name"`

	// ArgsDelta is a partial JSON byte slice update for the tool call arguments
	ArgsDelta []byte `json:"args_delta"`
}

func (b *ToolCallDeltaEvent) Type() EventType { return EventToolCallDelta }

// TODOTODO Stream Start.

// ResponseMetadataEvent contains additional response metadata.
//
// It will be sent as soon as it is available, without having to wait for
// the FinishEvent.
type ResponseMetadataEvent struct {
	// ID for the generated response, if the provider sends one
	ID string `json:"id,omitzero"`
	// Timestamp represents when the stream part was generated
	Timestamp time.Time `json:"timestamp,omitzero"`
	// ModelID for the generated response, if the provider sends one
	ModelID string `json:"model_id,omitzero"`
}

func (b *ResponseMetadataEvent) Type() EventType {
	return EventResponseMetadata
}

// FinishEvent represents the final part of the stream.
//
// It will be sent once the stream has finished processing.
type FinishEvent struct {
	// Usage contains token usage statistics
	Usage Usage `json:"usage,omitzero"`

	// FinishReason indicates why the model stopped generating
	FinishReason FinishReason `json:"finish_reason"`

	// ProviderMetadata contains provider-specific metadata
	ProviderMetadata *ProviderMetadata `json:"provider_metadata,omitzero"`
}

func (b *FinishEvent) Type() EventType { return EventFinish }

func (b *FinishEvent) GetProviderMetadata() *ProviderMetadata { return b.ProviderMetadata }

// ErrorEvent represents an error that occurred during streaming.
type ErrorEvent struct {
	// Err contains any error messages or error objects encountered during the stream
	Err any `json:"error"`

	// TODO: We might want to make sure that the error field is always serializable as JSON,
	// or we might force it to be an error type defined by our AI SDK so that the shape is
	// known if transmitted over the network.
}

func (b *ErrorEvent) Type() EventType { return EventError }
func (b *ErrorEvent) Error() string   { return fmt.Sprintf("%v", b.Err) }
